\subsection{Transacções e Controlo de Concorrência}

Quando o cliente faz um pedido ao master, seja de criação de novo objectos ou acesso a objectos já existentes, o master inicia uma nova transacção através do método TxBegin(). Após isso, os pedidos são enviados para os servidores, já inseridos naquela transacção específica. Durante o processamento, caso existam conflitos é retornado um valor boolean negativo, lançada a exepção TxException e a operação aborta através do método TxAbort(). 

Para o controlo de concorrência é usada a abordagem TimeStamp Ordering. Ao iniciar, as transacções ganham um timestamp. Isto permite impor a ordem de acesso aos dados e consequentemente resolver os conflitos mais cedo. Deste modo, caso uma transacção queira escrever num objecto (variável) que já lido por uma transacção com timestamp superior ao seu, detecta-se logo que isto não é válido, porque não mantinha a coerência dos dados. Assim que esta anomalia é detectada é feito abort e reduz-se a quantidade de trabalho desperdiçado, devido à detecção precoce. O mesmo se aplica caso uma transacção queira escrever ou ler num objecto que foi escrito por uma transacção com timestamp superior. Tome-se por excepção o caso em que uma transacção de escrita tenta escrever num objecto que já foi escrito por uma transacção com timestamp superior, não tendo este objecto ainda ter sido lido por outra transacção. Neste caso a escrita atrasada pode ser ignorada ao invés de ser feito abort, visto que ia ser sobreposta. Isto pode poupar recursos na medida em que se diminuem o número de transacções que reiniciam após terem sido abortadas.

Outra solução possível seria o uso de locks, pois também garante que no fim do processo não existem conflitos. No entanto, não optámos por esta solução porque, em relação ao TimeStamp Ordering, existe menos concorrência e queremos paralelizar a execução dos serviços ao máximo.

Outra vantagem desta abordagem é que não existem deadlocks. Além disto, quando uma transacção chega ao fim sabemos que pode fazer commit, pois caso existisse alguma anomalia já tinha sido detectada anteriormente. Caso existam no log versões a commitar e que a transacção actual precisa de ler, a abordagem escolhida é esperar pelo commit da outra transacção para prosseguir. Apesar da espera isto será transparente para o cliente.
